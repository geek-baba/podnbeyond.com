name: Deploy - Staging

on:
  push:
    branches:
      - main
    # Skip deployment for documentation-only changes
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.cursorrules'
      - 'README.md'
  workflow_dispatch:

# Cancel previous deployments when a new one starts
# This allows batching: if multiple commits are pushed quickly, only the latest deploys
# Note: To reduce cancellation email spam, configure GitHub notifications to not send
# emails for cancelled workflows (Settings → Notifications → GitHub Actions → uncheck "Cancelled")
concurrency:
  group: deploy-staging
  cancel-in-progress: true

jobs:
  # Debounce: Wait briefly to batch rapid commits and reduce cancellation emails
  # This waits 20 seconds before starting deployment, allowing multiple rapid commits
  # to be batched into a single deployment. If new commits arrive during this time,
  # this workflow will be cancelled and the new workflow will handle the latest commits.
  wait-for-batching:
    runs-on: ubuntu-latest
    timeout-minutes: 1
    steps:
      - name: Wait for batching rapid commits
        run: |
          echo "⏳ Waiting 20 seconds to batch rapid commits..."
          echo "If new commits arrive during this time, this workflow will be cancelled"
          echo "and the new workflow will handle the latest commits."
          sleep 20
          echo "✓ Batching period complete, proceeding with deployment"

  build-and-deploy:
    needs: wait-for-batching
    runs-on: ubuntu-latest
    # Only run if wait job completed successfully (not cancelled)
    # If wait job was cancelled, a new workflow will handle the latest commits
    if: success()

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.21.1'

      - name: Install backend dependencies
        working-directory: backend
        run: npm ci

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      # TODO: replace with real lint/test commands when available.
      - name: Run backend checks (placeholder)
        working-directory: backend
        run: npm run lint || echo "lint step skipped"

      - name: Run frontend checks (placeholder)
        working-directory: frontend
        run: npm run lint || echo "lint step skipped"

      - name: Build frontend
        working-directory: frontend
        env:
          NEXT_PUBLIC_BACKEND_URL: ${{ secrets.STAGING_NEXT_PUBLIC_BACKEND_URL }}
          NEXT_PUBLIC_API_URL: ${{ secrets.STAGING_NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_RAZORPAY_KEY_ID: ${{ secrets.STAGING_NEXT_PUBLIC_RAZORPAY_KEY_ID }}
        run: npm run build

      - name: Deploy to staging host
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.STAGING_DEPLOY_HOST }}
          username: ${{ secrets.STAGING_DEPLOY_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            set -e
            cd ${{ secrets.STAGING_DEPLOY_PATH }}
            git fetch --all
            git checkout main
            
            # Clean all untracked files first (including test scripts that might conflict)
            echo "Cleaning untracked files..."
            git clean -fd || true
            
            # Discard any local changes
            git reset --hard HEAD || true
            
            # Fetch latest changes
            git fetch origin main
            
            # Reset to origin/main (this avoids merge conflicts with untracked files)
            git reset --hard origin/main
            
            # Clean again to ensure clean state
            git clean -fd || true

            export DATABASE_URL='${{ secrets.STAGING_DATABASE_URL }}'
            export POSTMARK_TOKEN='${{ secrets.STAGING_POSTMARK_TOKEN }}'
            export RAZORPAY_KEY_ID='${{ secrets.STAGING_RAZORPAY_KEY_ID }}'
            export RAZORPAY_KEY_SECRET='${{ secrets.STAGING_RAZORPAY_KEY_SECRET }}'
            export NEXT_PUBLIC_BACKEND_URL='${{ secrets.STAGING_NEXT_PUBLIC_BACKEND_URL }}'
            export NEXT_PUBLIC_API_URL='${{ secrets.STAGING_NEXT_PUBLIC_API_URL }}'
            export NEXT_PUBLIC_RAZORPAY_KEY_ID='${{ secrets.STAGING_NEXT_PUBLIC_RAZORPAY_KEY_ID }}'
            export REDIS_ENABLED='${{ secrets.STAGING_REDIS_ENABLED }}'
            export REDIS_HOST='${{ secrets.STAGING_REDIS_HOST }}'
            export REDIS_PORT='${{ secrets.STAGING_REDIS_PORT }}'
            export QUEUE_PREFIX='staging'

            if [ -s "$HOME/.nvm/nvm.sh" ]; then
              export NVM_DIR="$HOME/.nvm"
              . "$NVM_DIR/nvm.sh"
            fi

            # Clean install backend dependencies
            cd backend
            rm -rf node_modules
            npm ci
            cd ..
            
            # Clean install frontend dependencies (handle npm ENOTEMPTY errors)
            cd frontend
            # Clean up everything that might cause issues
            echo "Cleaning up frontend dependencies..."
            rm -rf node_modules
            rm -rf .next
            rm -rf .next/cache
            npm cache clean --force || true
            # Ensure package-lock.json exists
            if [ ! -f "package-lock.json" ]; then
              echo "WARNING: package-lock.json not found, generating it..."
              npm install --package-lock-only
            fi
            # Clean install with retry logic
            echo "Installing frontend dependencies..."
            npm ci || (echo "First npm ci failed, cleaning and retrying..." && rm -rf node_modules && npm cache clean --force && npm ci)
            # If still failing, try npm install as fallback
            if [ ! -d "node_modules/next" ]; then
              echo "npm ci failed, trying npm install as fallback..."
              rm -rf node_modules
              npm cache clean --force
              npm install --legacy-peer-deps
            fi
            # Verify critical Next.js files exist
            if [ ! -d "node_modules/next" ]; then
              echo "ERROR: Next.js not installed properly!"
              exit 1
            fi
            if [ ! -f "node_modules/next/dist/compiled/jest-worker/processChild.js" ]; then
              echo "ERROR: Next.js jest-worker module missing! Reinstalling..."
              rm -rf node_modules/next
              npm install next --no-save
            fi
            # Verify napi-postinstall is properly installed (common issue)
            if [ ! -f "node_modules/napi-postinstall/package.json" ]; then
              echo "WARNING: napi-postinstall missing, reinstalling..."
              npm install napi-postinstall --no-save || true
            fi
            cd ..
            
                # Run Prisma migrations - critical for schema updates
                cd backend
                echo "Checking migration status..."
                MIGRATION_STATUS=$(npx prisma migrate status 2>&1 || true)
                echo "$MIGRATION_STATUS"
                
                # Check if there are any failed migrations
                if echo "$MIGRATION_STATUS" | grep -qi "failed"; then
                  echo "⚠️  Found failed migrations, attempting recovery..."
                  
                  # Check if the specific migration we're fixing is failed
                  if echo "$MIGRATION_STATUS" | grep -q "20251112220044_booking_module_phase1"; then
                    echo "Found failed migration: 20251112220044_booking_module_phase1"
                    echo "This migration failed due to enum default value issue (now fixed)."
                    echo "Attempting to recover using recovery script..."
                    
                    # Run recovery script to clean up partial migration
                    if [ -f "scripts/recover-failed-migration.js" ]; then
                      echo "Running recovery script..."
                      export DATABASE_URL="$DATABASE_URL"
                      if node scripts/recover-failed-migration.js 2>&1; then
                        echo "✓ Recovery script completed successfully"
                        echo "Will retry migration with fixed SQL..."
                      else
                        echo "⚠️  Recovery script failed, trying direct resolution..."
                        # Fallback to direct resolution
                        if npx prisma migrate resolve --rolled-back "20251112220044_booking_module_phase1" 2>&1; then
                          echo "✓ Migration marked as rolled back successfully"
                          echo "Will retry migration with fixed SQL..."
                        else
                          echo "⚠️  Could not automatically resolve failed migration"
                          echo "The migration may have partially succeeded."
                          echo ""
                          echo "To manually resolve, SSH into the server and run:"
                          echo "  cd backend"
                          echo "  export DATABASE_URL='your-database-url'"
                          echo "  node scripts/recover-failed-migration.js"
                          echo ""
                          echo "Or manually:"
                          echo "  npx prisma migrate resolve --rolled-back '20251112220044_booking_module_phase1'"
                          echo ""
                          echo "Then retry the deployment."
                          exit 1
                        fi
                      fi
                    else
                      echo "⚠️  Recovery script not found, trying direct resolution..."
                      # Fallback to direct resolution
                      if npx prisma migrate resolve --rolled-back "20251112220044_booking_module_phase1" 2>&1; then
                        echo "✓ Migration marked as rolled back successfully"
                        echo "Will retry migration with fixed SQL..."
                      else
                        echo "⚠️  Could not automatically resolve failed migration"
                        echo "Please manually resolve the migration or check the database state."
                        exit 1
                      fi
                    fi
                  else
                    echo "⚠️  Found other failed migrations that need manual resolution"
                    echo "$MIGRATION_STATUS"
                    exit 1
                  fi
                fi
                
                echo "Running Prisma migrations..."
                if npx prisma migrate deploy; then
                  echo "✓ Migrations applied successfully"
                else
                  echo "⚠️  Migration failed, checking migration status..."
                  npx prisma migrate status
                  echo ""
                  echo "ERROR: Migration failed! Manual intervention required."
                  echo "Please check the migration status and fix any issues before deploying."
                  exit 1
                fi
                
                # Generate Prisma client
                echo "Generating Prisma client..."
                npx prisma generate
                echo "✓ Prisma client generated"
                cd ..
            
            # Create .env.local for Next.js runtime (rewrites need this at runtime)
            echo "NEXT_PUBLIC_BACKEND_URL=${{ secrets.STAGING_NEXT_PUBLIC_BACKEND_URL }}" > frontend/.env.local
            echo "NEXT_PUBLIC_API_URL=${{ secrets.STAGING_NEXT_PUBLIC_API_URL }}" >> frontend/.env.local
            echo "NEXT_PUBLIC_RAZORPAY_KEY_ID=${{ secrets.STAGING_NEXT_PUBLIC_RAZORPAY_KEY_ID }}" >> frontend/.env.local
            
            NEXT_PUBLIC_BACKEND_URL='${{ secrets.STAGING_NEXT_PUBLIC_BACKEND_URL }}' \
            NEXT_PUBLIC_API_URL='${{ secrets.STAGING_NEXT_PUBLIC_API_URL }}' \
            NEXT_PUBLIC_RAZORPAY_KEY_ID='${{ secrets.STAGING_NEXT_PUBLIC_RAZORPAY_KEY_ID }}' \
            npm run build --prefix frontend

            # Verify build completed successfully
            if [ ! -d "frontend/.next" ]; then
              echo "ERROR: frontend/.next directory not found after build!"
              echo "Build may have failed. Checking for errors..."
              exit 1
            fi
            
            echo "✓ Frontend build completed successfully"
            echo "Build directory size: $(du -sh frontend/.next | cut -f1)"
            
            # Verify critical build artifacts exist
            if [ ! -d "frontend/.next/static" ]; then
              echo "ERROR: frontend/.next/static directory not found!"
              exit 1
            fi
            
            echo "✓ Static files directory exists"
            echo "Static directory contents:"
            ls -la frontend/.next/static/ | head -20
            
            # Check if build manifest exists
            BUILD_ID=$(cat frontend/.next/BUILD_ID 2>/dev/null || echo "unknown")
            echo "Build ID: $BUILD_ID"
            
            if [ ! -f "frontend/.next/BUILD_ID" ]; then
              echo "WARNING: BUILD_ID file not found, but continuing..."
            fi

            # Export env vars from .env.local for PM2 process
            export NEXT_PUBLIC_BACKEND_URL='${{ secrets.STAGING_NEXT_PUBLIC_BACKEND_URL }}'
            export NEXT_PUBLIC_API_URL='${{ secrets.STAGING_NEXT_PUBLIC_API_URL }}'
            export NEXT_PUBLIC_RAZORPAY_KEY_ID='${{ secrets.STAGING_NEXT_PUBLIC_RAZORPAY_KEY_ID }}'

            # Smart restart: Only restart if code/dependencies changed or process is errored
            echo "Checking if restart is needed..."
            
            # Get the last commit hash that triggered a restart (stored in a file)
            LAST_RESTART_FILE="/home/${{ secrets.STAGING_DEPLOY_USER }}/.last-staging-restart"
            CURRENT_COMMIT=$(git rev-parse HEAD)
            LAST_RESTART_COMMIT=$(cat "$LAST_RESTART_FILE" 2>/dev/null || echo "")
            
            # Check if backend/frontend code or dependencies changed
            NEEDS_RESTART=false
            if [ -z "$LAST_RESTART_COMMIT" ] || [ "$CURRENT_COMMIT" != "$LAST_RESTART_COMMIT" ]; then
              # Check what files changed since last restart
              if [ -n "$LAST_RESTART_COMMIT" ]; then
                CHANGED_FILES=$(git diff --name-only "$LAST_RESTART_COMMIT" HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES="all" # First deployment, restart everything
              fi
              
              # Check if backend code or dependencies changed
              if [ "$CHANGED_FILES" = "all" ] || echo "$CHANGED_FILES" | grep -qE "(backend/|package\.json|package-lock\.json|\.env|ecosystem\.config\.js)"; then
                echo "Backend code or dependencies changed, restart needed"
                NEEDS_RESTART=true
              fi
              
              # Check if frontend code or dependencies changed
              if [ "$CHANGED_FILES" = "all" ] || echo "$CHANGED_FILES" | grep -qE "(frontend/|package\.json|package-lock\.json|\.env|next\.config\.js)"; then
                echo "Frontend code or dependencies changed, restart needed"
                NEEDS_RESTART=true
              fi
            fi
            
            # Check if processes are errored or stopped (always restart in this case)
            BACKEND_ERRORED=false
            FRONTEND_ERRORED=false
            
            if pm2 list | grep -qE "staging-backend.*(errored|stopped)"; then
              echo "Backend process is errored or stopped, restart needed"
              BACKEND_ERRORED=true
              NEEDS_RESTART=true
            fi
            
            if pm2 list | grep -qE "staging-frontend.*(errored|stopped)"; then
              echo "Frontend process is errored or stopped, restart needed"
              FRONTEND_ERRORED=true
              NEEDS_RESTART=true
            fi
            
            # Restart or skip based on need
            if [ "$NEEDS_RESTART" = true ]; then
              echo "Restarting PM2 processes..."
              
              # Backend: delete if errored, then restart/start
              if [ "$BACKEND_ERRORED" = true ]; then
                echo "Backend is errored - deleting and recreating..."
                pm2 delete staging-backend 2>/dev/null || true
                sleep 1
                echo "Starting fresh backend process..."
                pm2 start ecosystem.config.js --only staging-backend --update-env
              elif pm2 list | grep -q "staging-backend"; then
                echo "Restarting backend process..."
                pm2 restart staging-backend --update-env
              else
                echo "Backend process not found, starting..."
                pm2 start ecosystem.config.js --only staging-backend --update-env
              fi
              
              # Frontend: delete if errored, then restart/start
              if [ "$FRONTEND_ERRORED" = true ]; then
                echo "Frontend is errored - deleting and recreating..."
                pm2 delete staging-frontend 2>/dev/null || true
                sleep 1
                echo "Starting fresh frontend process..."
                pm2 start ecosystem.config.js --only staging-frontend --update-env
              elif pm2 list | grep -q "staging-frontend"; then
                echo "Restarting frontend process..."
                pm2 restart staging-frontend --update-env
              else
                echo "Frontend process not found, starting..."
                pm2 start ecosystem.config.js --only staging-frontend --update-env
              fi
              
              # Save current commit as last restart commit
              echo "$CURRENT_COMMIT" > "$LAST_RESTART_FILE"
              echo "Saved restart commit: $CURRENT_COMMIT"
            else
              echo "✓ No restart needed - code and dependencies unchanged, processes are healthy"
              echo "Current commit: $CURRENT_COMMIT"
              echo "Last restart commit: $LAST_RESTART_COMMIT"
            fi
            
            echo "Waiting 5 seconds for processes to stabilize..."
            sleep 5
            
            echo "PM2 status:"
            pm2 list
            
            # Verify processes are running and stable
            BACKEND_ONLINE=false
            FRONTEND_ONLINE=false
            BACKEND_ERRORED=false
            FRONTEND_ERRORED=false
            
            for i in {1..5}; do
              # Check for errored status first (this is critical)
              if pm2 list | grep -q "staging-backend.*errored"; then
                BACKEND_ERRORED=true
              fi
              if pm2 list | grep -q "staging-frontend.*errored"; then
                FRONTEND_ERRORED=true
              fi
              
              # Check for online status
              if pm2 list | grep -q "staging-backend.*online"; then
                BACKEND_ONLINE=true
              fi
              if pm2 list | grep -q "staging-frontend.*online"; then
                FRONTEND_ONLINE=true
              fi
              
              if [ "$BACKEND_ONLINE" = true ] && [ "$FRONTEND_ONLINE" = true ] && [ "$BACKEND_ERRORED" != true ] && [ "$FRONTEND_ERRORED" != true ]; then
                break
              fi
              echo "Waiting for processes to come online... ($i/5)"
              sleep 2
            done
            
            # Check for errored status first (fail immediately if errored)
            if [ "$BACKEND_ERRORED" = true ]; then
              echo "❌ ERROR: Backend process is in ERRORED state!"
              echo "PM2 Status:"
              pm2 list
              echo ""
              echo "Backend logs (last 50 lines):"
              pm2 logs staging-backend --lines 50 --nostream || true
              echo ""
              echo "Backend error logs:"
              pm2 logs staging-backend --err --lines 50 --nostream || true
              exit 1
            fi
            
            if [ "$FRONTEND_ERRORED" = true ]; then
              echo "❌ ERROR: Frontend process is in ERRORED state!"
              echo "PM2 Status:"
              pm2 list
              echo ""
              echo "Frontend logs (last 50 lines):"
              pm2 logs staging-frontend --lines 50 --nostream || true
              echo ""
              echo "Frontend error logs:"
              pm2 logs staging-frontend --err --lines 50 --nostream || true
              exit 1
            fi
            
            if [ "$BACKEND_ONLINE" != true ]; then
              echo "❌ ERROR: Backend process is not online!"
              echo "PM2 Status:"
              pm2 list
              echo ""
              echo "Backend logs (last 50 lines):"
              pm2 logs staging-backend --lines 50 --nostream || true
              exit 1
            fi
            
            if [ "$FRONTEND_ONLINE" != true ]; then
              echo "❌ ERROR: Frontend process is not online!"
              echo "PM2 Status:"
              pm2 list
              echo ""
              echo "Frontend logs (last 50 lines):"
              pm2 logs staging-frontend --lines 50 --nostream || true
              exit 1
            fi
            
            pm2 save
            
            # Wait for server to be ready
            echo "Waiting for server to start..."
            sleep 15
            
            # Check PM2 status
            echo "PM2 Status:"
            pm2 list
            
            # Wait a bit more for services to fully initialize
            echo "Waiting for services to initialize..."
            sleep 5

      - name: Staging health check
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.STAGING_DEPLOY_HOST }}
          username: ${{ secrets.STAGING_DEPLOY_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            # Source nvm to get node/npm/pm2 in PATH
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            
            echo "Checking PM2 status first..."
            pm2 list || echo "PM2 list failed (non-critical)"
            
            echo "Waiting additional time for services to be ready..."
            sleep 10
            
            # Check if backend is listening on port first
            echo "Checking if backend is listening on port 8080..."
            for i in {1..10}; do
              if netstat -tlnp 2>/dev/null | grep -q ':8080' || ss -tlnp 2>/dev/null | grep -q ':8080'; then
                echo "✓ Backend is listening on port 8080"
                break
              fi
              if [ $i -eq 10 ]; then
                echo "⚠️  Backend not listening on port 8080 after 10 attempts"
              else
                echo "  Attempt $i/10: Backend not ready yet, waiting 2 seconds..."
                sleep 2
              fi
            done
            
            echo "Checking server health..."
            HEALTH_CHECK_URL="${{ secrets.STAGING_HEALTHCHECK_URL }}"
            
            # Wait a bit more for services to be fully ready
            echo "Waiting for services to be ready..."
            sleep 5
            
            # First check PM2 status - if any process is errored, fail immediately
            echo "Checking PM2 process status..."
            if pm2 list | grep -q "staging-backend.*errored"; then
              echo "❌ ERROR: Backend process is in ERRORED state!"
              echo "PM2 Status:"
              pm2 list
              echo ""
              echo "Backend logs (last 50 lines):"
              pm2 logs staging-backend --lines 50 --nostream || true
              echo ""
              echo "Backend error logs:"
              pm2 logs staging-backend --err --lines 50 --nostream || true
              exit 1
            fi
            
            if pm2 list | grep -q "staging-frontend.*errored"; then
              echo "❌ ERROR: Frontend process is in ERRORED state!"
              echo "PM2 Status:"
              pm2 list
              echo ""
              echo "Frontend logs (last 50 lines):"
              pm2 logs staging-frontend --lines 50 --nostream || true
              echo ""
              echo "Frontend error logs:"
              pm2 logs staging-frontend --err --lines 50 --nostream || true
              exit 1
            fi
            
            # Check if services are listening on ports
            echo "Checking if services are listening on ports..."
            BACKEND_PORT_OK=false
            FRONTEND_PORT_OK=false
            
            for i in {1..10}; do
              if netstat -tlnp 2>/dev/null | grep -q ':8080' || ss -tlnp 2>/dev/null | grep -q ':8080'; then
                BACKEND_PORT_OK=true
              fi
              if netstat -tlnp 2>/dev/null | grep -q ':3001' || ss -tlnp 2>/dev/null | grep -q ':3001'; then
                FRONTEND_PORT_OK=true
              fi
              if [ "$BACKEND_PORT_OK" = true ] && [ "$FRONTEND_PORT_OK" = true ]; then
                echo "✓ Both services are listening on ports"
                break
              fi
              echo "  Attempt $i/10: Waiting for services..."
              sleep 2
            done
            
            # Try health check
            if curl --fail --max-time 10 --retry 2 --retry-delay 2 -L "$HEALTH_CHECK_URL" 2>/dev/null; then
              echo "✓ Health check passed!"
            else
              echo "⚠️  Health check failed"
              echo "PM2 Status:"
              pm2 list || echo "PM2 not available in PATH"
              
              # Only consider it successful if ports are listening AND processes are online
              if [ "$BACKEND_PORT_OK" = true ] && [ "$FRONTEND_PORT_OK" = true ]; then
                # Double-check PM2 status one more time
                if pm2 list | grep -q "staging-backend.*online" && pm2 list | grep -q "staging-frontend.*online"; then
                  echo "✓ Services are listening on ports and PM2 shows them as online"
                  echo "Note: Health check endpoint may not be responding, but services appear to be up"
                else
                  echo "✗ Services are listening on ports but PM2 shows them as not online"
                  echo "PM2 Status:"
                  pm2 list
                  echo "PM2 Logs (last 50 lines):"
                  pm2 logs --lines 50 --nostream || echo "PM2 logs not available"
                  exit 1
                fi
              else
                echo "✗ Services are not listening on expected ports"
                echo "PM2 Logs (last 50 lines):"
                pm2 logs --lines 50 --nostream || echo "PM2 logs not available"
                exit 1
              fi
            fi

